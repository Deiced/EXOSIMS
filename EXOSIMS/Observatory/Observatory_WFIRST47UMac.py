from EXOSIMS.Observatory.ObservatoryL2Halo import ObservatoryL2Halo
import astropy.units as u
from astropy.time import Time
import numpy as np
import os, inspect
import scipy.interpolate as interpolate
import scipy.integrate as itg
try:
    import cPickle as pickle
except:
    import pickle
from scipy.io import loadmat

class Observatory_WFIRST47UMac(ObservatoryL2Halo):
    """ Observatory at L2 implementation. 
    The orbit method from the Observatory prototype is overloaded to implement
    a space telescope on a halo orbit about the Sun-Earth L2 point. This class

    Orbit is stored in pickled dictionary on disk (generated by MATLAB
    code adapted from E. Kolemen (2008).  Describes approx. 6 month halo
    which is then patched for the entire mission duration).
    
    """

    def __init__(self, equinox=60575.25, orbit_datapath=None, **specs):
        
        # run prototype constructor __init__ 
        ObservatoryL2Halo.__init__(self,**specs)


    # converting time 
    def convertTime_to_canonical(self,normTime):
        """ Convert time to canonical units
        """
        normTime = normTime.to('yr')
        return normTime.value * (2*np.pi)

    def convertTime_to_dim(self,normTime):
        """ Convert time to years
        """
        normTime = normTime / (2*np.pi) 
        return normTime * u.yr

    # converting length
    def convertPos_to_canonical(self,pos):
        """ Convert position to canonical units
        """
        pos = pos.to('au')
        return pos.value
    
    def convertPos_to_dim(self,pos):
        """ Convert position to canonical units
        """
        return pos * u.au 

    # converting velocity
    def convertVel_to_canonical(self,vel):
        """ Convert velocity to canonical units
        """
        vel = vel.to('au/yr')
        return vel.value / (2*np.pi)

    def convertVel_to_dim(self,vel):
        """ Convert velocity to canonical units
        """
        vel = vel * (2*np.pi)
        return vel * u.au / u.yr

    #converting angular velocity
    def convertAngVel_to_canonical(self,angvel):
        """ Convert velocity to canonical units
        """
        angvel = angvel.to('rad/yr')
        return angvel.value / (2*np.pi)

    def convertAngVel_to_dim(self,angvel):
        """ Convert velocity to canonical units
        """
        angvel = angvel * (2*np.pi)
        return angvel * u.rad / u.yr
    
    # converting acceleration
    def convertAcc_to_canonical(self,acc):
        """ Convert velocity to canonical units
        """
        acc = acc.to('au/yr**2')
        return acc.value / (2*np.pi)**2

    def convertAcc_to_dim(self,acc):
        """ Convert velocity to canonical units
        """
        acc = acc * (2*np.pi)**2
        return acc * u.au / u.yr**2   # converting angular velocity
    def convertAngVel_to_canonical(self,angvel):
        """ Convert velocity to canonical units
        """
        angvel = angvel.to('rad/yr')
        return angvel.value / (2*np.pi)

    def convertAngVel_to_dim(self,angvel):
        """ Convert velocity to canonical units
        """
        angvel = angvel * (2*np.pi)
        return angvel * u.rad / u.yr
		
    def unitVector(self,p):
        """ returns unit vector of p with same dimensions (3xn)
        """
        
        pnorm = np.linalg.norm(p,axis=0)
        p_ = p/pnorm
        
        return p_,pnorm

# =============================================================================
# Dynamics and Kinematics
# =============================================================================
    def EulerAngles(self,TL,sInd,currentTime,tRange):
        """ Get Euler Angle representation of Starshade position rel to Telescope
        """
        # coordinates of the star from the TL
        lamb = TL.coords.barycentrictrueecliptic.lon[sInd].to('rad')  #Longitude
        beta = TL.coords.barycentrictrueecliptic.lat[sInd].to('rad')  #Latitude
        varpi = TL.parx[sInd].to('rad')                                #parallax angle
        
        # time in canonical units
        absTimes = currentTime + tRange                   #mission times  in jd
        t = self.convertTime_to_canonical(np.mod(absTimes.value,self.equinox.value)*u.d) * u.rad
        
        # halo positions and velocities 
        haloPos = self.haloPosition(absTimes) + np.array([1,0,0])*self.L2_dist.to('au')
        haloVel = self.haloVelocity(absTimes)
        
        # halo positions and velocities in canonical units
        x,y,z    = np.array([self.convertPos_to_canonical(haloPos[:,n]) for n in range(3)])
        dx,dy,dz = np.array([self.convertVel_to_canonical(haloVel[:,n]) for n in range(3)])
        
        # nu angle (azimuth in B-frame)
        numNu = np.cos(beta)*np.sin(lamb-t)-varpi.value*y
        denNu = np.cos(beta)*np.cos(lamb-t)-varpi.value*x
        nu = np.arctan2(denNu,numNu)
        
        # some terms that will make my life easier
        varpiV         = varpi.value
        bigAngle       = -lamb + t + nu
        thatPeskyDenom =  varpiV*z - np.sin(beta)
        
        
        # gamma angle (colatitude in B-frame)
        numGam = (np.cos(beta)*np.sin(lamb-t)-varpiV*y)**2 + (np.cos(beta)*np.cos(lamb-t)-varpiV*x)**2
        numGam = np.sqrt(numGam)
        denGam = np.sin(beta)-varpiV*z
        gam = np.arctan2(denGam,numGam)
        
        # dnu angular speed (in canonical units)
        numDnu = np.cos(bigAngle)*np.cos(beta) - dx*varpiV*np.sin(nu) + dy*varpiV*np.cos(nu)
        denDnu = np.tan(gam)*thatPeskyDenom
        dnu = numDnu/denDnu
        
        # dgamma angular speed (in canonical units)
        numDgam = np.cos(gam) * ( np.sin(bigAngle)*np.cos(beta)*np.cos(gam) + dx*varpiV*np.cos(nu)*np.cos(gam) \
                         + dy*varpiV*np.sin(nu)*np.cos(gam) -dz*varpiV*np.sin(gam) )
        denDgam = thatPeskyDenom
        dgam = numDgam/denDgam
        
        return nu,gam,dnu,dgam
		
    
    
    def rotate_RorC(self,TL,sInd,trajStartTime,s_int,t_int,final_frame='C'):
        """
        
        Args:
            s_int (6xn):
                Integrated states in canonical units
            t_int (n):
                Integrated times in canonical units


        """
        # getting the associated 3-2-3 Euler set
        t_MJD = self.convertTime_to_dim( t_int )
        t_intMJD = t_MJD - t_MJD[0]
        nu,gam,dnu,dgam = self.EulerAngles(TL,sInd,trajStartTime,t_intMJD)
        Ra_S0_R , f_S0_R, fA_B, fL_B, theta = self.starshadeAcceleration(TL,sInd,trajStartTime,t_intMJD)
        
        # sign of rotation angle depending on rotating to C or R frame
        sign = 1 if final_frame == 'C' else -1
        print(sign)
        # extracting initial states
        x,y,z,dx,dy,dz = s_int
        r_i  = np.vstack([x,y,z])
        Rv_i = np.vstack([dx,dy,dz])
        # defining final states
        r_f = np.zeros(r_i.shape)
        Rv_f = np.zeros(Rv_i.shape)
        
        for n in range(len(t_int)):
            AcR = self.rot(nu[n],3)
            BcA = self.rot(gam[n],2)
            CcB = self.rot(theta[n],3)
            if sign == 1:
                fci = np.matmul( CcB,  np.matmul(BcA,AcR) )
            else:
                fci = np.matmul( AcR.T,  np.matmul(BcA.T,CcB.T))
            r_f[:,n]  = np.matmul( fci, r_i[:,n]  )
            Rv_f[:,n] = np.matmul( fci, Rv_i[:,n]  )
        
        return r_f , Rv_f